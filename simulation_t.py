import numpy as np
import math
import matplotlib.pyplot as plt

def run_simulation_t():


# 1. Physical Parameters
# ------------------------------------------------------------
# This section defines the physical properties of blood and the arterial wall.
# Blood is modeled as a Newtonian fluid with density (ρ) and viscosity (μ).
# The artery behaves as an elastic tube with radius r_ref, wall thickness h, and elasticity E.
# The relationship between pressure and area is given by the tube law p = α (A - A_ref),
# where α is the stiffness coefficient. The characteristic wave speed c = √(αA_ref / ρ)
# indicates how fast pressure and flow waves propagate through the vessel.
    rho = 1060.0          # kg/m^3
    mu = 3.5e-3           # Pa·s
    L = 0.15              # m
    D_ref = 3.0e-3        # m
    r_ref = D_ref / 2.0   # m
    E = 1.5e6             # Pa
    h = 1.0e-4            # m
    A_ref = math.pi * r_ref**2
    alpha = E * h / (2.0 * math.pi * r_ref**3)
    c = math.sqrt(alpha * A_ref / rho)
    # print(f"Wave speed c ≈ {c:.3f} m/s")


# 2. Numerical Setup
# ------------------------------------------------------------
# The artery is divided into small segments in space (Δx) and time (Δt).
# The CFL number (cΔt/Δx) determines the stability of the time integration.
# The total time T_final corresponds to one cardiac pulse, and z represents
# the spatial grid along the arterial length.
    dx = 1.0e-3
    dt = 1.0e-5
    T_final = 1.0  # one full 60 BPM pulse
    Nz = int(L / dx)
    Nzp1 = Nz + 1
    Nt = int(T_final / dt)
    z = np.linspace(0.0, L, Nzp1)
    t_array = np.linspace(0.0, T_final, Nt+1)
    CFL = c * dt / dx
    # print(f"CFL = {CFL:.3f}")


# 3. Inlet Pressure Waveform
# ------------------------------------------------------------
# The inlet boundary represents the pressure pulse generated by the heart.
# A smooth and physiological waveform is created using the Blackman–Harris window function.
# The pressure at the inlet (p_inlet) is converted into the corresponding area A_inlet
# using the tube law p = α (A - A_ref). This area serves as the time-varying input
# that drives the wave propagation through the artery.
LD, LP, LT = 0.60, 0.55, 0.55
tP, tD, tT = 0.38, 0.05, 0.20
betaP, betaD, betaT = 1.0, 0.4, 0.3
A_total_mmHg = 50.0
mmHg_to_Pa = 133.322
A_total = A_total_mmHg * mmHg_to_Pa

    def blackman_harris(x):
        if x < 0.0 or x > 1.0:
            return 0.0
        a0, a1, a2, a3 = 0.35875, 0.48829, 0.14128, 0.01168
        return a0 - a1*math.cos(2*math.pi*x) + a2*math.cos(4*math.pi*x) - a3*math.cos(6*math.pi*x)

    def p_inlet(t):
        xi_P = (t - tP) / LP
        xi_T = (t - tT) / LT
        xi_D = (t - tD) / LD
        wP = blackman_harris(xi_P)
        wT = blackman_harris(xi_T)
        wD = blackman_harris(xi_D)
        return A_total * (betaP*wP + betaT*wT + betaD*wD)

    def A_inlet(t):
        p = p_inlet(t)
        return A_ref + p / alpha


# 4. Mathematical Model
# ------------------------------------------------------------
# The one-dimensional blood flow equations are written in conservative form:
# U_t + F(U)_z = S(U)
# where U = [A, Q]^T,  F(U) = [Q, c²A]^T,  and  S(U) = [0, -dQ]^T.
# A is the cross-sectional area, Q is the volumetric flow rate,
# and the damping term d represents viscous losses in the blood.
# This form allows us to simulate wave propagation along the artery efficiently.
    d = 8.0 * math.pi * mu / (rho * A_ref)  # damping coefficient


# 5. Initial Conditions and Probe Locations
# ------------------------------------------------------------
# The artery starts from a steady state: A = A_ref (no pressure deviation), Q = 0 (no flow).
# Six observation points are defined along the artery (0 to L) to record the evolution
# of pressure, flow, and area over time, capturing how the pulse wave moves downstream.
    A = np.full(Nzp1, A_ref)
    Q = np.zeros(Nzp1)
    probe_z = np.array([0.0, 0.2*L, 0.4*L, 0.6*L, 0.8*L, L])
    probe_idx = [int(zp / dx) for zp in probe_z]
    probe_labels = [f"{zp/L:.1f}L" for zp in probe_z]
    time_store = []
    p_store = [[] for _ in probe_idx]
    Q_store = [[] for _ in probe_idx]
    A_store = [[] for _ in probe_idx]


# 6. Time Integration using MacCormack Scheme
# ------------------------------------------------------------
# The MacCormack method is used here to solve the time-dependent equations.
# It is a two-step predictor–corrector finite difference scheme that is second-order accurate.
# The predictor step uses forward differencing in space to estimate intermediate values,
# and the corrector step uses backward differencing to refine them.
#
# Boundary conditions:
# - Inlet (z = 0): The area A[0] is given by the prescribed inlet pulse (heart input).
#   The flow Q[0] uses a zero-gradient condition (Q[0] = Q[1]) for smooth adaptation.
# - Outlet (z = L): Zero-gradient boundary conditions (A[-1] = A[-2], Q[-1] = Q[-2])
#   are used so that waves can exit without reflection, simulating an open downstream artery.
    for n in range(Nt):
        t = n * dt

        # Apply boundary conditions
        A[0] = A_inlet(t)
        Q[0] = Q[1]
        A[-1] = A[-2]
        Q[-1] = Q[-2]

        # Predictor step (forward difference)
        A_star = A.copy()
        Q_star = Q.copy()
        for i in range(Nz):
            A_star[i] = A[i] - (dt/dx) * (Q[i+1] - Q[i])
            Q_star[i] = Q[i] - (c**2 * dt/dx) * (A[i+1] - A[i]) - d * dt * Q[i]

        # Apply BCs for predicted values
        A_star[0] = A_inlet(t + dt)
        Q_star[0] = Q_star[1]
        A_star[-1] = A_star[-2]
        Q_star[-1] = Q_star[-2]

        # Corrector step (backward difference)
        A_new = A.copy()
        Q_new = Q.copy()
        for i in range(1, Nzp1):
            A_new[i] = 0.5 * (A[i] + A_star[i] - (dt/dx)*(Q_star[i] - Q_star[i-1]))
            Q_new[i] = 0.5 * (Q[i] + Q_star[i]
                              - (c**2 * dt/dx)*(A_star[i] - A_star[i-1])
                              - d*dt*Q_star[i])

        # Update and reapply BCs
        A[:] = A_new
        Q[:] = Q_new
        A[0] = A_inlet(t + dt)
        Q[0] = Q[1]
        A[-1] = A[-2]
        Q[-1] = Q[-2]

        # Record at probe points
        if n % 1000 == 0:
            p = alpha * (A - A_ref)
            time_store.append(t)
            for j, idx in enumerate(probe_idx):
                p_store[j].append(p[idx])
                Q_store[j].append(Q[idx])
                A_store[j].append(A[idx])

    # print("Simulation done!")

    time_store = np.array(time_store)
    p_store = np.array(p_store)
    Q_store = np.array(Q_store)
    A_store = np.array(A_store)
    return time_store, p_store, Q_store, A_store, probe_labels


# 7. Visualization of Results
# ------------------------------------------------------------
# The results are plotted to show how pressure, flow, and cross-sectional area vary with time
# at six positions along the artery. The wave can be seen traveling and slightly attenuating
# as it moves downstream due to viscous effects and the wall’s elastic response.

def plot_simulation_t(time_store, p_store, Q_store, A_store, probe_labels):
    colors = plt.cm.viridis(np.linspace(0, 1, len(probe_labels)))
    plt.figure(figsize=(10, 8))
    plt.subplot(3,1,1)
    for j, lbl in enumerate(probe_labels):
        plt.plot(time_store, p_store[j]/133.322, color=colors[j], label=f'z={lbl}')
    plt.ylabel('Pressure [mmHg]')
    plt.legend(); plt.grid(True)
    plt.subplot(3,1,2)
    for j, lbl in enumerate(probe_labels):
        plt.plot(time_store, Q_store[j]*1e6, color=colors[j], label=f'z={lbl}')
    plt.ylabel('Flow Q [mm³/s]')
    plt.legend(); plt.grid(True)
    plt.subplot(3,1,3)
    for j, lbl in enumerate(probe_labels):
        plt.plot(time_store, A_store[j]*1e6, color=colors[j], label=f'z={lbl}')
    plt.ylabel('Area [mm²]')
    plt.xlabel('Time [s]')
    plt.legend(); plt.grid(True)
    plt.tight_layout()
    plt.show()

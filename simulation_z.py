import numpy as np
import math
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider


# 1. Physical and Numerical Parameters
# ------------------------------------------------------------
# This section defines the physical and mechanical properties of the artery and blood.
# Blood is modeled as a viscous, incompressible Newtonian fluid with density (ρ) and viscosity (μ).
# The artery is treated as an elastic tube with wall thickness (h) and Young’s modulus (E),
# which determines how it expands and contracts under pressure.
# The tube law p = α(A - A_ref) relates pressure to cross-sectional area,
# and the wave speed c = √(αA_ref / ρ) indicates how fast the pressure pulse travels through the vessel.
rho = 1060.0      # blood density [kg/m³]
mu = 3.5e-3       # viscosity [Pa·s]
L = 0.15          # artery length [m]
D_ref = 3.0e-3    # diameter [m]
r_ref = D_ref / 2.0
E = 1.5e6         # elastic modulus [Pa]
h = 1.0e-4        # wall thickness [m]

A_ref = math.pi * r_ref**2
alpha = E * h / (2.0 * math.pi * r_ref**3)
c = math.sqrt(alpha * A_ref / rho)
print(f"Wave speed c ≈ {c:.2f} m/s")

# The numerical grid divides the artery into small spatial segments (Δx)
# and advances the solution over small time steps (Δt). 
# The CFL number (cΔt/Δx) ensures that the wave does not travel more than one cell per step,
# maintaining stability of the time integration.
dx = 1.0e-3
dt = 1.0e-5
T_final = 1.0     # one full 60 BPM pulse
Nz = int(L / dx)
Nzp1 = Nz + 1
Nt = int(T_final / dt)
z = np.linspace(0.0, L, Nzp1)
CFL = c * dt / dx
print(f"CFL = {CFL:.3f}")


# 2. Inlet Pressure Waveform (60 BPM Pulse Model)
# ------------------------------------------------------------
# The inlet pressure represents the pulsatile action of the heart.
# A smooth Blackman–Harris window is used to construct a physiological waveform
# that mimics the time-varying pressure generated by the cardiac cycle.
# The inlet area is computed from this pressure using the tube law, and acts as
# the time-dependent boundary condition driving the wave through the artery.
LD, LP, LT = 0.60, 0.55, 0.55
tP, tD, tT = 0.38, 0.05, 0.20
betaP, betaD, betaT = 1.0, 0.4, 0.3
A_total_mmHg = 50.0
mmHg_to_Pa = 133.322
A_total = A_total_mmHg * mmHg_to_Pa

def blackman_harris(x):
    """Smooth window function on [0, 1]."""
    if x < 0.0 or x > 1.0:
        return 0.0
    a0, a1, a2, a3 = 0.35875, 0.48829, 0.14128, 0.01168
    return a0 - a1*np.cos(2*np.pi*x) + a2*np.cos(4*np.pi*x) - a3*np.cos(6*np.pi*x)

def p_inlet(t):
    xi_P = (t - tP) / LP
    xi_T = (t - tT) / LT
    xi_D = (t - tD) / LD
    wP, wT, wD = blackman_harris(xi_P), blackman_harris(xi_T), blackman_harris(xi_D)
    return A_total * (betaP*wP + betaT*wT + betaD*wD)

def A_inlet(t):
    return A_ref + p_inlet(t) / alpha


# 3. Flux and Source Terms
# ------------------------------------------------------------
# The governing equations are written in conservative form: U_t + F(U)_z = S(U),
# where U = [A, Q]^T, representing area and flow rate.
# The flux term F(U) represents the physical transport of area and momentum,
# while the source term S(U) accounts for viscous losses within the blood flow.
def flux(U):
    A, Q = U
    A_safe = np.maximum(A, 1e-12)
    return np.vstack((Q, Q**2 / A_safe + (alpha / (2.0 * rho)) * A_safe**2))

def source(U):
    A, Q = U
    A_safe = np.maximum(A, 1e-12)
    S2 = - (8.0 * math.pi * mu / rho) * Q / A_safe
    return np.vstack((np.zeros_like(A), S2))


# 4. Initial Conditions
# ------------------------------------------------------------
# The simulation starts with the artery at rest: uniform area (A_ref) and zero flow (Q = 0).
# These are stacked into a single array U = [A, Q].
A = np.full(Nzp1, A_ref)
Q = np.zeros(Nzp1)
U = np.vstack((A, Q))

# Snapshots will be saved at certain time intervals to visualize
# how pressure, flow, and area evolve with time and space.
save_every = 2000
snapshots_A, snapshots_Q, snapshots_P, times = [], [], [], []


# 5. MacCormack Time Integration
# ------------------------------------------------------------
# The MacCormack scheme is a predictor–corrector method that provides second-order accuracy.
# It first predicts the solution forward in space (predictor step),
# then corrects it backward in space (corrector step).
# Boundary conditions:
# - Inlet (z = 0): The area A is prescribed from the inlet waveform (A_inlet),
#   while Q uses a zero-gradient condition (Q[0] = Q[1]).
# - Outlet (z = L): Zero-gradient boundary conditions (A[-1] = A[-2], Q[-1] = Q[-2])
#   are applied to allow the wave to exit smoothly without reflection.
for n in range(Nt):
    t = n * dt

    # Boundary conditions
    U[0,0] = A_inlet(t)
    U[1,0] = U[1,1]
    U[0,-1] = U[0,-2]
    U[1,-1] = U[1,-2]

    # Predictor step
    F = flux(U)
    S = source(U)
    U_star = U.copy()
    U_star[:,1:-1] = U[:,1:-1] - (dt/dx)*(F[:,2:]-F[:,1:-1]) + dt*S[:,1:-1]

    # Predictor boundary conditions
    U_star[0,0] = A_inlet(t+dt)
    U_star[1,0] = U_star[1,1]
    U_star[0,-1] = U_star[0,-2]
    U_star[1,-1] = U_star[1,-2]

    # Corrector step
    F_star = flux(U_star)
    S_star = source(U_star)
    U[:,1:-1] = 0.5*(U[:,1:-1] + U_star[:,1:-1]
                    - (dt/dx)*(F_star[:,1:-1]-F_star[:,:-2])
                    + dt*S_star[:,1:-1])

    # Apply boundary conditions again for stability
    U[0,0] = A_inlet(t+dt)
    U[1,0] = U[1,1]
    U[0,-1] = U[0,-2]
    U[1,-1] = U[1,-2]

    # Store results periodically
    if n % save_every == 0:
        A, Q = U
        p = alpha * (A - A_ref)
        snapshots_A.append(A.copy())
        snapshots_Q.append(Q.copy())
        snapshots_P.append(p.copy())
        times.append(t)

print(f"Saved {len(times)} snapshots up to {T_final:.3f} s.")


# 6. Compute Full Inlet Pulse for Display
# ------------------------------------------------------------
# To visualize the inlet pressure waveform separately,
# it is computed over the full cardiac cycle and converted to mmHg for plotting.
t_wave = np.linspace(0, T_final, 1000)
p_wave = np.array([p_inlet(t) for t in t_wave]) / 133.322  # [mmHg]


# 7. Prepare Data for Visualization
# ------------------------------------------------------------
# The computed snapshots are converted to physical units suitable for display:
# pressure in mmHg, flow in mm³/s, and area in mm².
# These will be used to create interactive plots with a time slider.
snapshots_A = np.array(snapshots_A)
snapshots_Q = np.array(snapshots_Q)
snapshots_P = np.array(snapshots_P)
times = np.array(times)

z_mm = z * 1000
P_mmHg = snapshots_P / 133.322
Q_mm3s = snapshots_Q * 1e6
A_mm2 = snapshots_A * 1e6


# 8. Interactive Visualization with Slider
# ------------------------------------------------------------
# This section creates an interactive figure where a slider can move through time.
# The top plot shows the inlet pressure waveform, while the lower three show
# the spatial distribution of pressure, flow, and area along the artery at the selected time.
# This allows visualization of how the wave propagates and dissipates as it travels.
i0 = 0
fig, axs = plt.subplots(4, 1, figsize=(10, 10))
plt.subplots_adjust(bottom=0.25, hspace=0.6)

axs[0].plot(t_wave, p_wave, 'k', lw=2)
vline = axs[0].axvline(times[i0], color='r', lw=2)
axs[0].set_ylabel('Inlet P [mmHg]')
axs[0].set_title('Inlet Pulse Waveform (60 BPM)')
axs[0].grid(True)
axs[0].set_xlim(0, T_final)

lineP, = axs[1].plot(z_mm, P_mmHg[i0], 'r')
axs[1].set_ylabel('Pressure [mmHg]')
axs[1].grid(True)

lineQ, = axs[2].plot(z_mm, Q_mm3s[i0], 'b')
axs[2].set_ylabel('Flow [mm³/s]')
axs[2].grid(True)

lineA, = axs[3].plot(z_mm, A_mm2[i0], 'g')
axs[3].set_ylabel('Area [mm²]')
axs[3].set_xlabel('Axial coordinate z [mm]')
axs[3].grid(True)

# Adjust vertical scales for better visualization
axs[1].set_ylim(np.min(P_mmHg) - 10, np.max(P_mmHg) + 10)
axs[2].set_ylim(np.min(Q_mm3s) - 50, np.max(Q_mm3s) + 50)
axs[3].set_ylim(np.min(A_mm2) * 0.98, np.max(A_mm2) * 1.02)

# Create time slider
ax_slider = plt.axes([0.15, 0.08, 0.7, 0.03])
slider = Slider(ax_slider, 'Time [s]', times[0], times[-1], valinit=times[0])

def update(val):
    t_val = slider.val
    idx = np.argmin(np.abs(times - t_val))
    lineP.set_ydata(P_mmHg[idx])
    lineQ.set_ydata(Q_mm3s[idx])
    lineA.set_ydata(A_mm2[idx])
    vline.set_xdata(t_val)
    fig.suptitle(f"t = {times[idx]:.4f} s", fontsize=12)
    fig.canvas.draw_idle()

slider.on_changed(update)
plt.show()

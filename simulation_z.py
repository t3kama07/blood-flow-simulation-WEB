import numpy as np
import math
import matplotlib.pyplot as plt

def run_simulation_z():


# 1. Physical and Numerical Parameters
# ------------------------------------------------------------
# This section defines the physical and mechanical properties of the artery and blood.
# Blood is modeled as a viscous, incompressible Newtonian fluid with density (ρ) and viscosity (μ).
# The artery is treated as an elastic tube with wall thickness (h) and Young’s modulus (E),
# which determines how it expands and contracts under pressure.
# The tube law p = α(A - A_ref) relates pressure to cross-sectional area,
# and the wave speed c = √(αA_ref / ρ) indicates how fast the pressure pulse travels through the vessel.
    rho = 1060.0      # blood density [kg/m³]
    mu = 3.5e-3       # viscosity [Pa·s]
    L = 0.15          # artery length [m]
    D_ref = 3.0e-3    # diameter [m]
    r_ref = D_ref / 2.0
    E = 1.5e6         # elastic modulus [Pa]
    h = 1.0e-4        # wall thickness [m]

    A_ref = math.pi * r_ref**2
    alpha = E * h / (2.0 * math.pi * r_ref**3)
    c = math.sqrt(alpha * A_ref / rho)
    # print(f"Wave speed c ≈ {c:.2f} m/s")

# The numerical grid divides the artery into small spatial segments (Δx)
# and advances the solution over small time steps (Δt). 
# The CFL number (cΔt/Δx) ensures that the wave does not travel more than one cell per step,
# maintaining stability of the time integration.
    dx = 1.0e-3
    dt = 1.0e-5
    T_final = 1.0     # one full 60 BPM pulse
    Nz = int(L / dx)
    Nzp1 = Nz + 1
    Nt = int(T_final / dt)
    z = np.linspace(0.0, L, Nzp1)
    CFL = c * dt / dx
    # print(f"CFL = {CFL:.3f}")


# 2. Inlet Pressure Waveform (60 BPM Pulse Model)
# ------------------------------------------------------------
# The inlet pressure represents the pulsatile action of the heart.
# A smooth Blackman–Harris window is used to construct a physiological waveform
# that mimics the time-varying pressure generated by the cardiac cycle.
# The inlet area is computed from this pressure using the tube law, and acts as
# the time-dependent boundary condition driving the wave through the artery.
LD, LP, LT = 0.60, 0.55, 0.55
tP, tD, tT = 0.38, 0.05, 0.20
betaP, betaD, betaT = 1.0, 0.4, 0.3
A_total_mmHg = 50.0
mmHg_to_Pa = 133.322
A_total = A_total_mmHg * mmHg_to_Pa

    def blackman_harris(x):
        """Smooth window function on [0, 1]."""
        if x < 0.0 or x > 1.0:
            return 0.0
        a0, a1, a2, a3 = 0.35875, 0.48829, 0.14128, 0.01168
        return a0 - a1*np.cos(2*np.pi*x) + a2*np.cos(4*np.pi*x) - a3*np.cos(6*np.pi*x)

    def p_inlet(t):
        xi_P = (t - tP) / LP
        xi_T = (t - tT) / LT
        xi_D = (t - tD) / LD
        wP, wT, wD = blackman_harris(xi_P), blackman_harris(xi_T), blackman_harris(xi_D)
        return A_total * (betaP*wP + betaT*wT + betaD*wD)

    def A_inlet(t):
        return A_ref + p_inlet(t) / alpha


# 3. Flux and Source Terms
# ------------------------------------------------------------
# The governing equations are written in conservative form: U_t + F(U)_z = S(U),
# where U = [A, Q]^T, representing area and flow rate.
# The flux term F(U) represents the physical transport of area and momentum,
# while the source term S(U) accounts for viscous losses within the blood flow.
    def flux(U):
        A, Q = U
        A_safe = np.maximum(A, 1e-12)
        return np.vstack((Q, Q**2 / A_safe + (alpha / (2.0 * rho)) * A_safe**2))

    def source(U):
        A, Q = U
        A_safe = np.maximum(A, 1e-12)
        S2 = - (8.0 * math.pi * mu / rho) * Q / A_safe
        return np.vstack((np.zeros_like(A), S2))


# 4. Initial Conditions
# ------------------------------------------------------------
# The simulation starts with the artery at rest: uniform area (A_ref) and zero flow (Q = 0).
# These are stacked into a single array U = [A, Q].
    A = np.full(Nzp1, A_ref)
    Q = np.zeros(Nzp1)
    U = np.vstack((A, Q))

    # Snapshots will be saved at certain time intervals to visualize
    # how pressure, flow, and area evolve with time and space.
    save_every = 2000
    snapshots_A, snapshots_Q, snapshots_P, times = [], [], [], []


# 5. MacCormack Time Integration
# ------------------------------------------------------------
# The MacCormack scheme is a predictor–corrector method that provides second-order accuracy.
# It first predicts the solution forward in space (predictor step),
# then corrects it backward in space (corrector step).
# Boundary conditions:
# - Inlet (z = 0): The area A is prescribed from the inlet waveform (A_inlet),
#   while Q uses a zero-gradient condition (Q[0] = Q[1]).
# - Outlet (z = L): Zero-gradient boundary conditions (A[-1] = A[-2], Q[-1] = Q[-2])
#   are applied to allow the wave to exit smoothly without reflection.
    for n in range(Nt):
        t = n * dt

        # Boundary conditions
        U[0,0] = A_inlet(t)
        U[1,0] = U[1,1]
        U[0,-1] = U[0,-2]
        U[1,-1] = U[1,-2]

        # Predictor step
        F = flux(U)
        S = source(U)
        U_star = U.copy()
        U_star[:,1:-1] = U[:,1:-1] - (dt/dx)*(F[:,2:]-F[:,1:-1]) + dt*S[:,1:-1]

        # Predictor boundary conditions
        U_star[0,0] = A_inlet(t+dt)
        U_star[1,0] = U_star[1,1]
        U_star[0,-1] = U_star[0,-2]
        U_star[1,-1] = U_star[1,-2]

        # Corrector step
        F_star = flux(U_star)
        S_star = source(U_star)
        U[:,1:-1] = 0.5*(U[:,1:-1] + U_star[:,1:-1]
                        - (dt/dx)*(F_star[:,1:-1]-F_star[:,:-2])
                        + dt*S_star[:,1:-1])

        # Apply boundary conditions again for stability
        U[0,0] = A_inlet(t+dt)
        U[1,0] = U[1,1]
        U[0,-1] = U[0,-2]
        U[1,-1] = U[1,-2]

        # Store results periodically
        if n % save_every == 0:
            A, Q = U
            p = alpha * (A - A_ref)
            snapshots_A.append(A.copy())
            snapshots_Q.append(Q.copy())
            snapshots_P.append(p.copy())
            times.append(t)

    # print(f"Saved {len(times)} snapshots up to {T_final:.3f} s.")

    snapshots_A = np.array(snapshots_A)
    snapshots_Q = np.array(snapshots_Q)
    snapshots_P = np.array(snapshots_P)
    times = np.array(times)
    z_mm = z * 1000
    P_mmHg = snapshots_P / 133.322
    Q_mm3s = snapshots_Q * 1e6
    A_mm2 = snapshots_A * 1e6
    return z_mm, P_mmHg, Q_mm3s, A_mm2, times


# 6. Compute Full Inlet Pulse for Display
# ------------------------------------------------------------
# To visualize the inlet pressure waveform separately,
# it is computed over the full cardiac cycle and converted to mmHg for plotting.
t_wave = np.linspace(0, T_final, 1000)
p_wave = np.array([p_inlet(t) for t in t_wave]) / 133.322  # [mmHg]


# 7. Prepare Data for Visualization
# ------------------------------------------------------------
# The computed snapshots are converted to physical units suitable for display:
# pressure in mmHg, flow in mm³/s, and area in mm².
# These will be used to create interactive plots with a time slider.
snapshots_A = np.array(snapshots_A)
snapshots_Q = np.array(snapshots_Q)
snapshots_P = np.array(snapshots_P)
times = np.array(times)


def plot_simulation_z(z_mm, P_mmHg, Q_mm3s, A_mm2, times, time_idx=0):
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    axes[0].plot(z_mm, P_mmHg[time_idx], 'r-', linewidth=2, marker='o', markersize=4)
    axes[0].set_ylabel('Pressure [mmHg]', fontweight='bold')
    axes[0].set_title(f'Spatial Distribution at t={times[time_idx]:.4f}s', fontweight='bold')
    axes[0].grid(True, alpha=0.3)
    axes[1].plot(z_mm, Q_mm3s[time_idx], 'b-', linewidth=2, marker='s', markersize=4)
    axes[1].set_ylabel('Flow [mm³/s]', fontweight='bold')
    axes[1].grid(True, alpha=0.3)
    axes[2].plot(z_mm, A_mm2[time_idx], 'g-', linewidth=2, marker='^', markersize=4)
    axes[2].set_ylabel('Area [mm²]', fontweight='bold')
    axes[2].set_xlabel('Position along artery z [mm]', fontweight='bold')
    axes[2].grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()
